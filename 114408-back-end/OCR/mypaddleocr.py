# -*- coding: utf-8 -*-
"""MyPaddleOCR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P_-TW7y6NjDJ7vWNMd-5Zu4EzlR_39aY
"""

!python -m pip install paddlepaddle==3.1.0 -i https://www.paddlepaddle.org.cn/packages/stable/cpu/
!pip install paddleocr

from paddleocr import PaddleOCR
from matplotlib import pyplot as plt
import cv2
import os

!pip install opencc

import opencc

from paddleocr import DocPreprocessor, PaddleOCR

ocr = PaddleOCR(
    use_doc_orientation_classify=False,
    use_doc_unwarping=False,
    use_textline_orientation=False)

"""傳統發票"""

from google.colab import files

uploaded = files.upload()

img_path = list(uploaded.keys())[0]  # 取得上傳的檔案名稱
image = cv2.imread(img_path)

image_RGB = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(10,6))
plt.imshow(image_RGB)
plt.axis('off')
plt.show()

# 進行 OCR
result = ocr.predict(img_path)[0]

result

texts = result['rec_texts']
scores = result['rec_scores']
polys = result['dt_polys']

# 輸出所有文字與分數
for text, score in zip(texts, scores):
    print(f'{text}（分數：{score:.3f}）')

boxes = result['dt_polys']
print(boxes)

import cv2
import numpy as np
import random

image = cv2.imread(img_path)

for box in boxes:
    box = np.array(box).astype(int)
    color = (0, 0, 255)
    cv2.polylines(
        image,
        [box],
        isClosed=True,
        color=color,
        thickness=3
    )

image_RGB = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(10,6))
plt.imshow(image_RGB)
plt.axis('off')
plt.show()

converter = opencc.OpenCC('s2t.json')
for item in result['rec_texts']:
    print(converter.convert(item))

"""電子發票"""

from google.colab import files

uploaded = files.upload()

img_path = list(uploaded.keys())[0]  # 取得上傳的檔案名稱
image = cv2.imread(img_path)

image_RGB = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(10,6))
plt.imshow(image_RGB)
plt.axis('off')
plt.show()

# 進行 OCR
result = ocr.predict(img_path)[0]

result

texts = result['rec_texts']
scores = result['rec_scores']
polys = result['dt_polys']

# 輸出所有文字與分數
for text, score in zip(texts, scores):
    print(f'{text}（分數：{score:.3f}）')

boxes = result['dt_polys']
print(boxes)

import cv2
import numpy as np
import random

image = cv2.imread(img_path)

for box in boxes:
    box = np.array(box).astype(int)
    color = (0, 0, 255)
    cv2.polylines(
        image,
        [box],
        isClosed=True,
        color=color,
        thickness=3
    )

image_RGB = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(10,6))
plt.imshow(image_RGB)
plt.axis('off')
plt.show()

converter = opencc.OpenCC('s2t.json')
for item in result['rec_texts']:
    print(converter.convert(item))

"""二聯式發票(無前處理)"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
import random



print("請上傳圖片檔案...")
uploaded = files.upload()
img_path = list(uploaded.keys())[0]

# 僅讀取一次圖片
image = cv2.imread(img_path)

# 處理讀取失敗的情況
if image is None:
    print("錯誤：無法讀取圖片，請檢查檔案路徑。")
else:

    image_RGB = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(10, 6))
    plt.imshow(image_RGB)
    plt.title('原始圖片')
    plt.axis('off')
    plt.show()


    print("\n--- 進行 OCR 辨識 ---")
    try:
        result = ocr.predict(img_path)[0]
    except Exception as e:
        print(f"OCR 辨識失敗：{e}")
        result = None

    if result:
        texts = result['rec_texts']
        scores = result['rec_scores']
        boxes = result['dt_polys']


        print("\n--- 辨識出的文字與分數 ---")
        for text, score in zip(texts, scores):
            print(f'文字：{text}（分數：{score:.3f}）')

        image_with_boxes = image.copy()
        for box in boxes:
            box = np.array(box).astype(int)
            # 將顏色固定為紅色 (BGR: 藍0, 綠0, 紅255)
            color = (0, 0, 255)
            cv2.polylines(image_with_boxes, [box], isClosed=True, color=color, thickness=3)

        # 顯示帶有邊框的圖片
        image_with_boxes_RGB = cv2.cvtColor(image_with_boxes, cv2.COLOR_BGR2RGB)
        plt.figure(figsize=(10, 6))
        plt.imshow(image_with_boxes_RGB)
        plt.title('帶有文字邊框的圖片')
        plt.axis('off')
        plt.show()


        print("\n--- 簡體中文轉換為繁體中文 ---")
        converter = opencc.OpenCC('s2t.json')
        for item in texts:
            print(converter.convert(item))

"""二聯式發票(有前處理)"""

# ───────────────── 安裝 ─────────────────
!pip install -q opencv-python-headless numpy matplotlib

# ───────────────── 匯入 ─────────────────
import cv2, numpy as np, matplotlib.pyplot as plt
from google.colab import files
import os

def show(img, title='', gray=False, size=(12,7)):
    plt.figure(figsize=size)
    if gray: plt.imshow(img, cmap='gray')
    else:    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.axis('off'); plt.title(title); plt.show()

# ───────────────── 只抓藍色（HSV + 綠否決） ─────────────────
def blue_mask_hsv_simple(img_bgr,
                         blue_h=(105,130), blue_s=(30,255), blue_v=(30,255),
                         green_h=(45,85), green_s_min=25, green_v_min=40,
                         morph_ksize=3, min_area=12, max_area_ratio=0.02, keep_stamp=False):
    h, w = img_bgr.shape[:2]
    hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)

    bmask = cv2.inRange(hsv, (blue_h[0], blue_s[0], blue_v[0]),
                              (blue_h[1], blue_s[1], blue_v[1]))
    gmask = cv2.inRange(hsv, (green_h[0], green_s_min, green_v_min),
                              (green_h[1], 255, 255))
    bmask = cv2.bitwise_and(bmask, cv2.bitwise_not(gmask))

    k = cv2.getStructuringElement(cv2.MORPH_RECT, (morph_ksize, morph_ksize))
    bmask = cv2.morphologyEx(bmask, cv2.MORPH_CLOSE, k, 1)
    bmask = cv2.morphologyEx(bmask, cv2.MORPH_OPEN,  k, 1)

    num, labels, stats, _ = cv2.connectedComponentsWithStats(bmask, connectivity=8)
    out = np.zeros_like(bmask)
    max_area = None if (keep_stamp or max_area_ratio is None) else int(h*w*max_area_ratio)
    for i in range(1, num):
        area = stats[i, cv2.CC_STAT_AREA]
        if area < min_area: continue
        if (max_area is not None) and (area > max_area): continue
        out[labels==i] = 255
    return out

# ───────────────── 只留文字與數字：v7 ─────────────────
def filter_text_numbers_v7(
    mask_blue,
    thin_hline_len=210, thin_vline_len=140, max_line_thickness=3,
    min_area=6, max_area=11000, aspect_max=9.5, aspect_min=0.14,
    stamp_roi_ratio=(0.60, 0.56, 0.98, 0.98),
    dense_kernel=45, dense_area_ratio=0.016, dense_iter=2,
    border_margin=20, border_small_max=6000,
    top_band_px=220, top_band_wmin=50, top_band_areamax=7000,
    right_strip_px=120, circ_min=0.65, round_min_area=60,
    auto_sw=True, sw_floor=0.8, sw_quantile=10, sw_min_manual=1.4,
    amount_roi_ratio=(0.35, 0.34, 0.82, 0.66),
    rescue_area=45, rescue_h=10, rescue_solidity=0.33
):
    H, W = mask_blue.shape

    # A) 去長線
    hk = cv2.getStructuringElement(cv2.MORPH_RECT, (thin_hline_len, max(1,max_line_thickness)))
    vk = cv2.getStructuringElement(cv2.MORPH_RECT, (max(1,max_line_thickness), thin_vline_len))
    lines = cv2.bitwise_or(cv2.morphologyEx(mask_blue, cv2.MORPH_OPEN, hk, 1),
                           cv2.morphologyEx(mask_blue, cv2.MORPH_OPEN, vk, 1))
    mask = cv2.bitwise_and(mask_blue, cv2.bitwise_not(lines))

    # B) 幾何過濾
    num, labels, stats, _ = cv2.connectedComponentsWithStats(mask, connectivity=8)
    geom = np.zeros_like(mask)
    for i in range(1, num):
        x,y,w,h,area = stats[i]
        if area < min_area or area > max_area: continue
        ar = w/float(h) if h>0 else 1e9
        if ar > aspect_max or ar < aspect_min: continue
        fill = area/float(w*h)
        if (w>120 and h>120 and fill<0.22):
            continue
        geom[labels==i] = 255

    # C) 邊界/帶狀清理
    n2, lab2, st2, _ = cv2.connectedComponentsWithStats(geom, connectivity=8)
    cleaned = np.zeros_like(geom)
    for i in range(1, n2):
        x,y,w,h,area = st2[i]
        touch = (x<=border_margin or y<=border_margin or
                 x+w>=W-border_margin or y+h>=H-border_margin)
        if touch and area < border_small_max:
            continue
        cleaned[lab2==i] = 255

    nB, lB, sB, _ = cv2.connectedComponentsWithStats(cleaned, connectivity=8)
    for i in range(1, nB):
        x,y,w,h,area = sB[i]
        if y < top_band_px and w >= top_band_wmin and area <= top_band_areamax:
            cleaned[lB==i] = 0
        elif x+w > W-right_strip_px and area < 16000:
            cleaned[lB==i] = 0

    # D) 圓孔
    cnts, _ = cv2.findContours(cleaned, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for c in cnts:
        area = cv2.contourArea(c)
        if area < round_min_area: continue
        peri = cv2.arcLength(c, True)
        if peri == 0: continue
        circ = 4.0*np.pi*area/(peri*peri)
        if circ >= circ_min:
            cv2.drawContours(cleaned, [c], -1, 0, -1)

    # E) 章聚類（只在右下 ROI）
    x0r,y0r,x1r,y1r = stamp_roi_ratio
    x0,y0 = int(W*x0r), int(H*y0r)
    x1,y1 = int(W*x1r), int(H*y1r)
    roi_mask = np.zeros_like(cleaned); roi_mask[y0:y1, x0:x1] = 255
    roi_only = cv2.bitwise_and(cleaned, roi_mask)
    if roi_only.any():
        k = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (dense_kernel, dense_kernel))
        dil = roi_only.copy()
        for _ in range(dense_iter): dil = cv2.dilate(dil, k, 1)
        nn, ll, st, _ = cv2.connectedComponentsWithStats(dil, connectivity=8)
        big = np.zeros_like(cleaned)
        dense_area = int(H*W*dense_area_ratio)
        for i in range(1, nn):
            if st[i, cv2.CC_STAT_AREA] > dense_area:
                big[ll==i] = 255
        cleaned = cv2.bitwise_and(cleaned, cv2.bitwise_not(big))

    # F) 筆畫寬度 + 救援
    dt = cv2.distanceTransform((cleaned>0).astype(np.uint8), cv2.DIST_L2, 3)
    n3, l3, s3, _ = cv2.connectedComponentsWithStats(cleaned, connectivity=8)

    sw_vals, regs, stats_list, solidity_vals = [], [], [], []
    for i in range(1, n3):
        region = (l3==i)
        sw_vals.append(float(dt[region].mean()))
        regs.append(region); stats_list.append(s3[i])
        ys, xs = np.where(region)
        if len(xs) >= 3:
            hull = cv2.convexHull(np.stack([xs, ys], axis=1).astype(np.int32))
            hull_area = cv2.contourArea(hull)
            solid = s3[i, cv2.CC_STAT_AREA] / max(hull_area, 1.0)
        else:
            solid = 0.0
        solidity_vals.append(solid)

    if len(sw_vals)==0:
        return cleaned
    thr = max(np.percentile(np.array(sw_vals), sw_quantile), sw_floor) if auto_sw else sw_min_manual

    ax0, ay0, ax1, ay1 = amount_roi_ratio
    AX0, AY0, AX1, AY1 = int(W*ax0), int(H*ay0), int(W*ax1), int(H*ay1)

    final = np.zeros_like(cleaned)
    for region, s, st_i, solid in zip(regs, sw_vals, stats_list, solidity_vals):
        x,y,w,h,area = st_i
        cx, cy = x+w//2, y+h//2
        in_amt_roi = (AX0 <= cx <= AX1) and (AY0 <= cy <= AY1)
        keep_by_sw = (s >= thr)
        keep_by_rescue_roi = in_amt_roi and area >= 35 and h >= 9
        keep_by_solidity = (area >= rescue_area and h >= rescue_h and solid >= rescue_solidity)
        if keep_by_sw or keep_by_rescue_roi or keep_by_solidity:
            final[region] = 255

    final = cv2.morphologyEx(final, cv2.MORPH_CLOSE,
                             cv2.getStructuringElement(cv2.MORPH_RECT,(2,2)), 2)
    return final

# ───────────────── 兩塊「保留 ROI」的小工具 ─────────────────
def build_keep_roi(mask, ratios, close=(7,7), dilate=(3,3),
                   min_area=20, kill_hline=180):
    H, W = mask.shape
    x0r, y0r, x1r, y1r = ratios
    X0, Y0, X1, Y1 = int(W*x0r), int(H*y0r), int(W*x1r), int(H*y1r)

    roi = mask[Y0:Y1, X0:X1].copy()
    roi = cv2.morphologyEx(roi, cv2.MORPH_CLOSE,
                           cv2.getStructuringElement(cv2.MORPH_ELLIPSE, close), 2)
    roi = cv2.dilate(roi, cv2.getStructuringElement(cv2.MORPH_RECT, dilate), 1)

    if kill_hline:
        hline = cv2.morphologyEx(
            roi, cv2.MORPH_OPEN,
            cv2.getStructuringElement(cv2.MORPH_RECT, (kill_hline, 1)), 1
        )
        roi = cv2.bitwise_and(roi, cv2.bitwise_not(hline))

    num, lab, st, _ = cv2.connectedComponentsWithStats(roi, 8)
    keep = np.zeros_like(roi)
    for i in range(1, num):
        if st[i, cv2.CC_STAT_AREA] >= min_area:
            keep[lab == i] = 255
    return (X0, Y0, X1, Y1, keep)

# ───────────────── 主流程 ─────────────────
uploaded = files.upload()
os.makedirs("only_blue_outputs", exist_ok=True)

for name in uploaded:
    img = cv2.imread(name)

    # (A) 只留藍色 + 全域輕微加粗
    mask_blue = blue_mask_hsv_simple(img)
    mask_blue = cv2.dilate(mask_blue, cv2.getStructuringElement(cv2.MORPH_RECT,(3,3)), 1)

    # 兩塊保護 ROI：①金額 ②右下備註（收窄，避免碰章）
    AX0, AY0, AX1, AY1, keep_amount = build_keep_roi(
        mask_blue, ratios=(0.36, 0.32, 0.78, 0.62),
        close=(7,7), dilate=(3,3), min_area=20, kill_hline=180
    )
    NX0, NY0, NX1, NY1, keep_note = build_keep_roi(
        mask_blue, ratios=(0.36, 0.72, 0.74, 0.92),
        close=(5,5), dilate=(2,2), min_area=16, kill_hline=240
    )
    keep_patches = [(AX0, AY0, AX1, AY1, keep_amount),
                    (NX0, NY0, NX1, NY1, keep_note)]

    # (B) 只留文字/數字（章專殺、上緣/右側雜訊、放寬幾何）
    mask_text = filter_text_numbers_v7(
        mask_blue,
        stamp_roi_ratio=(0.58, 0.52, 0.99, 0.99),
        dense_kernel=60, dense_iter=3, dense_area_ratio=0.010,
        top_band_px=260, top_band_areamax=12000, right_strip_px=120,
        thin_hline_len=260, thin_vline_len=140, max_line_thickness=3,
        min_area=2, max_area=60000, aspect_max=60.0, aspect_min=0.06,
        circ_min=0.90, round_min_area=420,
        auto_sw=False, sw_min_manual=0.0,
        amount_roi_ratio=(0.28, 0.22, 0.92, 0.74),
        rescue_area=12, rescue_h=5, rescue_solidity=0.18
    )

    # (C) 後處理：長線 + 邊界小雜點
    H, W = mask_text.shape
    num, lab, st, _ = cv2.connectedComponentsWithStats(mask_text, 8)
    for i in range(1, num):
        x, y, w, h, area = st[i]
        if h <= 3 and w >= int(0.12 * W):
            mask_text[lab == i] = 0

    band_h = int(0.22 * H)
    band = mask_text[:band_h, :].copy()
    num, lab, st, _ = cv2.connectedComponentsWithStats(band, 8)
    for i in range(1, num):
        x, y, w, h, area = st[i]
        if w >= int(0.08 * W) and h <= 18:
            band[lab == i] = 0
    mask_text[:band_h, :] = band

    num, lab, st, _ = cv2.connectedComponentsWithStats(mask_text, 8)
    clean = np.zeros_like(mask_text)
    for i in range(1, num):
        x, y, w, h, area = st[i]
        touch = (x < 10 or y < 10 or x+w > W-10 or y+h > H-10)
        if touch and area < 6000: continue
        if area >= 18: clean[lab == i] = 255
    mask_text = clean

    # (D) 把兩塊保護 ROI OR 回來（金額 + 右下備註）
    for X0, Y0, X1, Y1, roi_keep in keep_patches:
        mask_text[Y0:Y1, X0:X1] = cv2.bitwise_or(mask_text[Y0:Y1, X0:X1], roi_keep)

    # (E) 最終「章硬刪」——兩段式，清到乾淨
    # 1) 章所在大 ROI（往左/上擴一點）
    sx0, sy0, sx1, sy1 = (0.700, 0.55, 0.995, 0.995)  # ← 原本 0.745, 0.60 再擴
    S0, T0, S1, T1 = int(W*sx0), int(H*sy0), int(W*sx1), int(H*sy1)

    # 先刪 ROI 內所有連通元件
    num, lab, st, _ = cv2.connectedComponentsWithStats(mask_text, 8)
    for i in range(1, num):
      x, y, w, h, area = st[i]
      cx, cy = x + w//2, y + h//2
      if S0 <= cx <= S1 and T0 <= cy <= T1:
        mask_text[lab == i] = 0

    # 再把該 ROI 膨脹 1~2px 後整塊清空（避免邊緣殘留）
    kill = np.zeros_like(mask_text)
    kill[T0:T1, S0:S1] = 255
    kill = cv2.dilate(kill, cv2.getStructuringElement(cv2.MORPH_RECT,(7,7)), 1)  # ← 由 (5,5) → (7,7)
    mask_text = cv2.bitwise_and(mask_text, cv2.bitwise_not(kill))

    # 2) 右緣保險帶（最容易殘字的窄區域）：整條清空
    strip_w = int(0.06 * W)                     # 右側約 6% 寬（可調 0.05~0.08）
    strip = np.zeros_like(mask_text)
    strip[:, W-strip_w:] = 255
    strip = cv2.dilate(strip, cv2.getStructuringElement(cv2.MORPH_RECT,(3,3)), 1)
    mask_text = cv2.bitwise_and(mask_text, cv2.bitwise_not(strip))


    # (F) 輸出：binary + color
    gray  = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    bw    = np.zeros_like(gray); bw[mask_text==255] = 255
    bw    = cv2.morphologyEx(bw, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_RECT,(3,3)), 1)
    bw    = cv2.morphologyEx(bw, cv2.MORPH_OPEN,  cv2.getStructuringElement(cv2.MORPH_RECT,(2,2)), 1)

    color = np.full_like(img, 255); color[mask_text==255] = img[mask_text==255]

    show(img,       "Original")
    show(mask_blue, "Blue Mask", gray=True)
    show(bw,        "Text & Numbers Only (binary)", gray=True)
    show(color,     "Text & Numbers Only (color)")

print("完成！")

"""三聯式發票(無前處理)"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
import random



print("請上傳圖片檔案...")
uploaded = files.upload()
img_path = list(uploaded.keys())[0]

# 僅讀取一次圖片
image = cv2.imread(img_path)

# 處理讀取失敗的情況
if image is None:
    print("錯誤：無法讀取圖片，請檢查檔案路徑。")
else:

    image_RGB = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(10, 6))
    plt.imshow(image_RGB)
    plt.title('原始圖片')
    plt.axis('off')
    plt.show()


    print("\n--- 進行 OCR 辨識 ---")
    try:
        result = ocr.predict(img_path)[0]
    except Exception as e:
        print(f"OCR 辨識失敗：{e}")
        result = None

    if result:
        texts = result['rec_texts']
        scores = result['rec_scores']
        boxes = result['dt_polys']


        print("\n--- 辨識出的文字與分數 ---")
        for text, score in zip(texts, scores):
            print(f'文字：{text}（分數：{score:.3f}）')

        image_with_boxes = image.copy()
        for box in boxes:
            box = np.array(box).astype(int)
            # 將顏色固定為紅色 (BGR: 藍0, 綠0, 紅255)
            color = (0, 0, 255)
            cv2.polylines(image_with_boxes, [box], isClosed=True, color=color, thickness=3)

        # 顯示帶有邊框的圖片
        image_with_boxes_RGB = cv2.cvtColor(image_with_boxes, cv2.COLOR_BGR2RGB)
        plt.figure(figsize=(10, 6))
        plt.imshow(image_with_boxes_RGB)
        plt.title('帶有文字邊框的圖片')
        plt.axis('off')
        plt.show()


        print("\n--- 簡體中文轉換為繁體中文 ---")
        converter = opencc.OpenCC('s2t.json')
        for item in texts:
            print(converter.convert(item))